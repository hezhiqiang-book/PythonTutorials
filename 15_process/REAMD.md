# 进程

> 隔离资源，OS资源分配的最小单位

## 进程是怎么被调度？

- 先来先服务算法 FCFS
- 段作业有限算法
- 时间片轮转算法
- 多级反馈算法
  - 优先1 = [p1,p3,p4,p5]
  - 优先2 = [p1,p2,p3]
  - 优先3 = []
- 现代OS中大多使用了多级反馈算法

## 并发与并行

- 并行：两者同时执行（资源够用，三个线程，四核的CPU）
- 并发：资源有限的情况下，两者交替轮流使用资源

- 异步：只管调度，不管结果
- 同步：调度之后，必须等待结果

- 同步与异步：获取完成标志的方式。如果是采用轮询的方式监测I/O操作是否完成称为同步，而以通过回调通知的方式获得完成标志则称为异步。

- 阻塞与非阻塞：在那段时间差的过程中，CPU有没有处理别的事情，如果处理过别的事情则是非阻塞，如果并没有处理过别的事情则是阻塞。

![阻塞与非阻塞](./imags/1.png)

*1,2代表轮询I/O操作的进行状态，3代表I/O操作已经完成
我们把一个I/O调用看做上面A和B两个过程，A阶段是CPU发出I/O调用【此阶段是十分快速的】，B阶段是相关设备把数据从目标位置转移到用户空间的过程【此阶段就会由于数据量以及数据所在设备的远近而所用时间大为不同】，容易明白的是上面四个概念都是针对B阶段在数据迁移过程中此进程/线程所对应的CPU状态而言的，所以用这个过程来看看上面四个概念的组合：

1.同步阻塞：即是在B阶段CPU一直采用轮询的方式直到获得完成标志，所以此段时间CPU一直阻塞在此I/O操作上。

2.同步不阻塞：在B阶段依然采用轮询的方式直至获得完成标志，但是此轮询不同于上面的轮询过程，而是在相邻的轮询中完成了上下文切换去处理别的任务的，所以是同步不阻塞

3.异步阻塞：也就是所没有上面的1,2过程，当I/O操作完成后回调通知CPU已完成【即是3过程】，但是此阶段CPU处于休眠状态而不处理别的任务。

4.异步不阻塞：和上面一样没有1,2过程而是通过回调知道I/O操作已完成，但是并没有休眠，而是在此阶段处理其他任务。

综上所述：异步不阻塞是最高效的。

 在实际中常采用多线程模拟理想异步非阻塞模式：一个主线程用于计算，多个线程用于执行I/O操作【可能是上面四种的任意形式】

![阻塞与非阻塞](./imags/1.png)

几种常见服务器模型：

　　1.同步式：一次处理一个请求，其余请求处于等待状态

　　2.每请求/每进程: 为每个请求启动一个进程【不具备扩展功能，系统志愿有限】

　　3.每请求/每线程：为每个请求启动一个线程【每个线程占一定内存，故受限于内存，还会拖慢服务器】【Apache就是采用的这种方式】

　　4.事件驱动：Node与Nginx采用事件驱动方式而不创建新线程【省去了线程创建/删除的系统开销以及线程上下文切换，所以能够处理更多的连接】【python的Twisted，Ruby的Event Machine以及Perl的AyEvent也是事件驱动，但是他们并不是很成功】

 

需要注意的是对于高并发【注释1】的程序往往采用“同步非阻塞”而不是“多线程的同步阻塞”，在合理设计任务调度的不同阶段可使得并发数远大于并行数，需要注意的是在高并发状况下为每个任务创建一个线程的开销很大，所以并不采用多线程的同步阻塞。

并发：同时进行的任务数量

并行：可同时工作的物理资源（CPU核数等等）

另外，有个概念是异步IO，其主要是说在同一线程中当遭遇IO时，并不等待而是执行下面的操作直到IO操作完成后再切回当前，其实就是同步非阻塞。

## multiprocess 模块

> 综合封装了subprocess，不能同时两个都使用

## process 模块

> 创建进程相关